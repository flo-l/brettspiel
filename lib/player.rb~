# A Player represents a player in real life
# Each Player has a name, maybe customizable
# A Player has honor and up to three items he has to collect
# The Player Object also keeps track of the amount of resources (aka carsd) a player has
# TODO: A Player could have an array which could hold additional information added by events

# The Cards are wrapped in a CardHand object which offers an own API
# eg: player.cards.count  # overall amount of cards a player has
#     player.cards.swords # amount of swords

# It's possible to add an item to a player like so:
# player.items << item
# There are convenience methods available, that check for the presence
# of one or all of the three items a player should collect

class Player
  attr_reader :name, :id, :current_location, :honor, :cards, :items

  # Player ids start with 1, gets incremented everytime a player object is created
  @@id_count = 0

  def initialize(name)
    @name = name
    @id = @@id_count += 1

    @current_location = GAME.locations[1]
    @honor = 0
    @cards = CardHand.new

    #TODO: add start cards here
    change_cards(1,1,1)

    @items = []
    def @items.add(item)
      message(:item_gained, @id, item.name)
      self << item
    end

    def @items.remove(item)
      message(:item_lost, @id, item.name)
      self.delete(item)
    end
  end

  # This fires a move message and sets current_location to its argument
  def current_location=(location)
    @current_location = location
    message(:move, @id, @current_location.id)
  end

  # This fires an event if the honor of a player is changed
  def honor=(n)
    amount = n - @honor
    message(:honor, @id, amount)
    @honor = n
  end

  # Adds the given amount of cards to the hand and fires a card_change message
  def change_cards(swords, shields, supply)
    @cards.swords += swords
    @cards.shields += shields
    @cards.supply += supply

    message(:change_cards, @id, swords, shields, supply)
  end

  # This lets the player vistit the next stop, finds out the event and finally let's it occur
  def do_turn
    @current_location = get_next_stop
    message(:move, @id, @current_location.id) #so dumm es auch ist...

    event = @current_location.select_event(get_mode)

    event.display!

    event.occur!
  end

  def get_next_stop
    loop do
      options = {@current_location.id => @current_location}
      @current_location.neighbours.each { |l| options[l.id] = l }
      auswahl_id = message(:question, @id, 0, "Wohin soll die Reise gehen? Zur Auswahl stehen: ", options)

      return GAME.locations[auswahl_id]
    end
  end

  def get_mode
    message(:question, @id, 0, "Wie wollen sie den Ort betreten?", {:investigate => "Offen", :hidden => "Versteckt"} )
  end

  def to_s
    @name
  end
end

class CardHand
  attr_accessor :swords, :shields, :supply

  def initialize
    @swords = 0
    @shields = 0
    @supply = 0
  end

  def count
    @swords + @shields + @supply
  end
end
